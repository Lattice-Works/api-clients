/*
 * OpenLattice API
 *
 * OpenLattice API
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@openlattice.com
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct DataApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> DataApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> DataApiClient<C> {
        DataApiClient {
            configuration,
        }
    }
}

pub trait DataApi {
    fn create_associations(&self, inline_object: crate::models::InlineObject) -> Box<dyn Future<Item = ::std::collections::HashMap<String, Vec<String>>, Error = Error<serde_json::Value>>>;
    fn create_edges(&self, data_edge_key: Vec<crate::models::DataEdgeKey>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn create_entities(&self, set_id: &str, request_body: Vec<::std::collections::HashMap<String, Vec<String>>>) -> Box<dyn Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn create_entity_and_association_data(&self, data_graph: crate::models::DataGraph) -> Box<dyn Future<Item = crate::models::DataGraphIds, Error = Error<serde_json::Value>>>;
    fn delete_all_entities_from_entity_set(&self, entity_set_id: &str, _type: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn delete_entities(&self, entity_set_id: &str, _type: &str, request_body: Vec<String>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn delete_entities_and_neighbors(&self, entity_set_id: &str, _type: &str, entity_neighbors_filter: Vec<crate::models::EntityNeighborsFilter>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn delete_entity(&self, entity_set_id: &str, entity_key_id: &str, _type: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn delete_entity_properties(&self, entity_set_id: &str, entity_key_id: &str, _type: &str, request_body: Vec<String>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_entity(&self, entity_set_id: &str, entity_key_id: &str) -> Box<dyn Future<Item = ::std::collections::HashMap<String, Vec<String>>, Error = Error<serde_json::Value>>>;
    fn get_entity_property_values(&self, entity_set_id: &str, entity_key_id: &str, property_type_id: &str) -> Box<dyn Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn get_entity_set_size(&self, entity_set_id: &str) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn load_entity_set_data(&self, entity_set_id: &str) -> Box<dyn Future<Item = Vec<::std::collections::HashMap<String, Vec<String>>>, Error = Error<serde_json::Value>>>;
    fn load_linked_entity_set_breakdown(&self, linked_entity_set_id: &str, entity_set_selection: Vec<crate::models::EntitySetSelection>) -> Box<dyn Future<Item = ::std::collections::HashMap<String, ::std::collections::HashMap<String, ::std::collections::HashMap<String, ::std::collections::HashMap<String, Vec<String>>>>>, Error = Error<serde_json::Value>>>;
    fn load_selected_entity_set_data(&self, entity_set_id: &str, entity_set_selection: Vec<crate::models::EntitySetSelection>) -> Box<dyn Future<Item = Vec<::std::collections::HashMap<String, Vec<String>>>, Error = Error<serde_json::Value>>>;
    fn replace_association_data(&self, partial: bool, request_body: ::std::collections::HashMap<String, ::std::collections::HashMap<String, crate::models::DataEdge>>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn replace_entity_properties(&self, entity_set_id: &str, request_body: ::std::collections::HashMap<String, ::std::collections::HashMap<String, Vec<::std::collections::HashMap<String, String>>>>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn update_entities_in_entity_set(&self, entity_set_id: &str, _type: &str, request_body: ::std::collections::HashMap<String, ::std::collections::HashMap<String, Vec<String>>>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>>;
}

impl<C: hyper::client::Connect>DataApi for DataApiClient<C> {
    fn create_associations(&self, inline_object: crate::models::InlineObject) -> Box<dyn Future<Item = ::std::collections::HashMap<String, Vec<String>>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/data/association".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_body_param(inline_object);

        req.execute(self.configuration.borrow())
    }

    fn create_edges(&self, data_edge_key: Vec<crate::models::DataEdgeKey>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/datastore/data/association".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_body_param(data_edge_key);

        req.execute(self.configuration.borrow())
    }

    fn create_entities(&self, set_id: &str, request_body: Vec<::std::collections::HashMap<String, Vec<String>>>) -> Box<dyn Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/data/set/".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_query_param("setId".to_string(), set_id.to_string());
        req = req.with_body_param(request_body);

        req.execute(self.configuration.borrow())
    }

    fn create_entity_and_association_data(&self, data_graph: crate::models::DataGraph) -> Box<dyn Future<Item = crate::models::DataGraphIds, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/data".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_body_param(data_graph);

        req.execute(self.configuration.borrow())
    }

    fn delete_all_entities_from_entity_set(&self, entity_set_id: &str, _type: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/datastore/data/set/{entitySetId}/all".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_query_param("type".to_string(), _type.to_string());
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn delete_entities(&self, entity_set_id: &str, _type: &str, request_body: Vec<String>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/datastore/data/set/{entitySetId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_query_param("type".to_string(), _type.to_string());
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.with_body_param(request_body);

        req.execute(self.configuration.borrow())
    }

    fn delete_entities_and_neighbors(&self, entity_set_id: &str, _type: &str, entity_neighbors_filter: Vec<crate::models::EntityNeighborsFilter>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/data/set/{entitySetId}/neighbors".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_query_param("type".to_string(), _type.to_string());
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.with_body_param(entity_neighbors_filter);

        req.execute(self.configuration.borrow())
    }

    fn delete_entity(&self, entity_set_id: &str, entity_key_id: &str, _type: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/datastore/data/{entitySetId}/{entityKeyId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_query_param("type".to_string(), _type.to_string());
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.with_path_param("entityKeyId".to_string(), entity_key_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn delete_entity_properties(&self, entity_set_id: &str, entity_key_id: &str, _type: &str, request_body: Vec<String>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/datastore/data/{entitySetId}/{entityKeyId}/properties".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_query_param("type".to_string(), _type.to_string());
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.with_path_param("entityKeyId".to_string(), entity_key_id.to_string());
        req = req.with_body_param(request_body);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn get_entity(&self, entity_set_id: &str, entity_key_id: &str) -> Box<dyn Future<Item = ::std::collections::HashMap<String, Vec<String>>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/data/{entitySetId}/{entityKeyId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.with_path_param("entityKeyId".to_string(), entity_key_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_entity_property_values(&self, entity_set_id: &str, entity_key_id: &str, property_type_id: &str) -> Box<dyn Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/data/{entitySetId}/{entityKeyId}/{propertyTypeId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.with_path_param("entityKeyId".to_string(), entity_key_id.to_string());
        req = req.with_path_param("propertyTypeId".to_string(), property_type_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_entity_set_size(&self, entity_set_id: &str) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/data/{entitySetId}/count".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn load_entity_set_data(&self, entity_set_id: &str) -> Box<dyn Future<Item = Vec<::std::collections::HashMap<String, Vec<String>>>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/data/set/{entitySetId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn load_linked_entity_set_breakdown(&self, linked_entity_set_id: &str, entity_set_selection: Vec<crate::models::EntitySetSelection>) -> Box<dyn Future<Item = ::std::collections::HashMap<String, ::std::collections::HashMap<String, ::std::collections::HashMap<String, ::std::collections::HashMap<String, Vec<String>>>>>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/data/set/{linkedEntitySetId}/detailed".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("linkedEntitySetId".to_string(), linked_entity_set_id.to_string());
        req = req.with_body_param(entity_set_selection);

        req.execute(self.configuration.borrow())
    }

    fn load_selected_entity_set_data(&self, entity_set_id: &str, entity_set_selection: Vec<crate::models::EntitySetSelection>) -> Box<dyn Future<Item = Vec<::std::collections::HashMap<String, Vec<String>>>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/data/set/{entitySetId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.with_body_param(entity_set_selection);

        req.execute(self.configuration.borrow())
    }

    fn replace_association_data(&self, partial: bool, request_body: ::std::collections::HashMap<String, ::std::collections::HashMap<String, crate::models::DataEdge>>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/datastore/data/association".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_query_param("partial".to_string(), partial.to_string());
        req = req.with_body_param(request_body);

        req.execute(self.configuration.borrow())
    }

    fn replace_entity_properties(&self, entity_set_id: &str, request_body: ::std::collections::HashMap<String, ::std::collections::HashMap<String, Vec<::std::collections::HashMap<String, String>>>>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/datastore/data/set/{entitySetId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.with_body_param(request_body);

        req.execute(self.configuration.borrow())
    }

    fn update_entities_in_entity_set(&self, entity_set_id: &str, _type: &str, request_body: ::std::collections::HashMap<String, ::std::collections::HashMap<String, Vec<String>>>) -> Box<dyn Future<Item = i32, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/datastore/data/set/{entitySetId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_query_param("type".to_string(), _type.to_string());
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.with_body_param(request_body);

        req.execute(self.configuration.borrow())
    }

}
