/*
 * OpenLattice API
 *
 * OpenLattice API
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@openlattice.com
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct OrganizationsApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> OrganizationsApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> OrganizationsApiClient<C> {
        OrganizationsApiClient {
            configuration,
        }
    }
}

pub trait OrganizationsApi {
    fn add_member(&self, organization_id: &str, user_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn add_role_to_user(&self, organization_id: &str, role_id: &str, user_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn assemble_entity_sets(&self, organization_id: &str, request_body: ::std::collections::HashMap<String, i32>) -> Box<dyn Future<Item = ::std::collections::HashMap<String, Vec<String>>, Error = Error<serde_json::Value>>>;
    fn create_organization_if_not_exists(&self, organization: crate::models::Organization) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn create_role(&self, role: crate::models::Role) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn delete_role(&self, organization_id: &str, role_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn destroy_organization(&self, organization_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_all_users_of_role(&self, organization_id: &str, role_id: &str) -> Box<dyn Future<Item = Vec<crate::models::Auth0userBasic>, Error = Error<serde_json::Value>>>;
    fn get_auto_approved_email_domains(&self, organization_id: &str) -> Box<dyn Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn get_flagged_organization_entity_sets(&self, organization_id: &str, request_body: ::std::collections::HashMap<String, Vec<String>>) -> Box<dyn Future<Item = Vec<::std::collections::HashMap<String, Vec<String>>>, Error = Error<serde_json::Value>>>;
    fn get_members(&self, organization_id: &str) -> Box<dyn Future<Item = Vec<crate::models::OrganizationMember>, Error = Error<serde_json::Value>>>;
    fn get_organization(&self, organization_id: &str) -> Box<dyn Future<Item = crate::models::Organization, Error = Error<serde_json::Value>>>;
    fn get_organization_entity_sets(&self, organization_id: &str) -> Box<dyn Future<Item = ::std::collections::HashMap<String, Vec<String>>, Error = Error<serde_json::Value>>>;
    fn get_organization_integration_account(&self, organization_id: &str) -> Box<dyn Future<Item = crate::models::InlineResponse200, Error = Error<serde_json::Value>>>;
    fn get_organizations(&self, ) -> Box<dyn Future<Item = Vec<crate::models::Organization>, Error = Error<serde_json::Value>>>;
    fn get_role(&self, organization_id: &str, role_id: &str) -> Box<dyn Future<Item = crate::models::Role, Error = Error<serde_json::Value>>>;
    fn get_roles(&self, organization_id: &str) -> Box<dyn Future<Item = Vec<crate::models::Role>, Error = Error<serde_json::Value>>>;
    fn refresh_data_changes(&self, organization_id: &str, entity_set_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn remove_auto_approved_email_domains(&self, organization_id: &str, request_body: Vec<String>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn remove_member(&self, organization_id: &str, user_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn remove_role_from_user(&self, organization_id: &str, role_id: &str, user_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_auto_approved_email_domain(&self, organization_id: &str, request_body: Vec<String>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn synchronize_edm_changes(&self, organization_id: &str, entity_set_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn update_description(&self, organization_id: &str, body: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn update_role_description(&self, organization_id: &str, role_id: &str, body: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn update_role_title(&self, organization_id: &str, role_id: &str, body: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn update_title(&self, organization_id: &str, body: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
}

impl<C: hyper::client::Connect>OrganizationsApi for OrganizationsApiClient<C> {
    fn add_member(&self, organization_id: &str, user_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/datastore/organizations/{organizationId}/principals/members/{userId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("userId".to_string(), user_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn add_role_to_user(&self, organization_id: &str, role_id: &str, user_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/datastore/organizations/{organizationId}/principals/roles/{roleId}/members/{userId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("roleId".to_string(), role_id.to_string());
        req = req.with_path_param("userId".to_string(), user_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn assemble_entity_sets(&self, organization_id: &str, request_body: ::std::collections::HashMap<String, i32>) -> Box<dyn Future<Item = ::std::collections::HashMap<String, Vec<String>>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/organizations/{organizationId}/entity-sets/assemble".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_body_param(request_body);

        req.execute(self.configuration.borrow())
    }

    fn create_organization_if_not_exists(&self, organization: crate::models::Organization) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/organizations".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_body_param(organization);

        req.execute(self.configuration.borrow())
    }

    fn create_role(&self, role: crate::models::Role) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/organizations/roles".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_body_param(role);

        req.execute(self.configuration.borrow())
    }

    fn delete_role(&self, organization_id: &str, role_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/datastore/organizations/{organizationId}/principals/roles/{roleId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("roleId".to_string(), role_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn destroy_organization(&self, organization_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/datastore/organizations/{organizationId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn get_all_users_of_role(&self, organization_id: &str, role_id: &str) -> Box<dyn Future<Item = Vec<crate::models::Auth0userBasic>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/organizations/{organizationId}/principals/roles/{roleId}/members/".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("roleId".to_string(), role_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_auto_approved_email_domains(&self, organization_id: &str) -> Box<dyn Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/organizations/{organizationId}/email-domains".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_flagged_organization_entity_sets(&self, organization_id: &str, request_body: ::std::collections::HashMap<String, Vec<String>>) -> Box<dyn Future<Item = Vec<::std::collections::HashMap<String, Vec<String>>>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/organizations/{organizationId}/entity-sets".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_body_param(request_body);

        req.execute(self.configuration.borrow())
    }

    fn get_members(&self, organization_id: &str) -> Box<dyn Future<Item = Vec<crate::models::OrganizationMember>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/organizations/{organizationId}/principals/members".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_organization(&self, organization_id: &str) -> Box<dyn Future<Item = crate::models::Organization, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/organizations/{organizationId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_organization_entity_sets(&self, organization_id: &str) -> Box<dyn Future<Item = ::std::collections::HashMap<String, Vec<String>>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/organizations/{organizationId}/entity-sets".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_organization_integration_account(&self, organization_id: &str) -> Box<dyn Future<Item = crate::models::InlineResponse200, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/organizations/{organizationId}/integration".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_organizations(&self, ) -> Box<dyn Future<Item = Vec<crate::models::Organization>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/organizations".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;

        req.execute(self.configuration.borrow())
    }

    fn get_role(&self, organization_id: &str, role_id: &str) -> Box<dyn Future<Item = crate::models::Role, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/organizations/{organizationId}/principals/roles/{roleId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("roleId".to_string(), role_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_roles(&self, organization_id: &str) -> Box<dyn Future<Item = Vec<crate::models::Role>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/datastore/organizations/{organizationId}/principals/roles".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn refresh_data_changes(&self, organization_id: &str, entity_set_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/organizations/{organizationId}/{entitySetId}/refresh".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn remove_auto_approved_email_domains(&self, organization_id: &str, request_body: Vec<String>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/datastore/organizations/{organizationId}/email-domains".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_body_param(request_body);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn remove_member(&self, organization_id: &str, user_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/datastore/organizations/{organizationId}/principals/members/{userId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("userId".to_string(), user_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn remove_role_from_user(&self, organization_id: &str, role_id: &str, user_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/datastore/organizations/{organizationId}/principals/roles/{roleId}/members/{userId}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("roleId".to_string(), role_id.to_string());
        req = req.with_path_param("userId".to_string(), user_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn set_auto_approved_email_domain(&self, organization_id: &str, request_body: Vec<String>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/datastore/organizations/{organizationId}/email-domains".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_body_param(request_body);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn synchronize_edm_changes(&self, organization_id: &str, entity_set_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/organizations/{organizationId}/{entitySetId}/synchronize".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("entitySetId".to_string(), entity_set_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn update_description(&self, organization_id: &str, body: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/datastore/organizations/{organizationId}/description".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_body_param(body);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn update_role_description(&self, organization_id: &str, role_id: &str, body: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/datastore/organizations/{organizationId}/principals/roles/{roleId}/description".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("roleId".to_string(), role_id.to_string());
        req = req.with_body_param(body);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn update_role_title(&self, organization_id: &str, role_id: &str, body: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/datastore/organizations/{organizationId}/principals/roles/{roleId}/title".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_path_param("roleId".to_string(), role_id.to_string());
        req = req.with_body_param(body);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn update_title(&self, organization_id: &str, body: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/datastore/organizations/{organizationId}/title".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("organizationId".to_string(), organization_id.to_string());
        req = req.with_body_param(body);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

}
